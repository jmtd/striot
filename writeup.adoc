= Rewrites
Jonathan Dowland <jon.dowland@ncl.ac.uk>
:toc: right
:toclevels: 4


== Abstract

We describe STRIoT: a stream-processing system built around pure
functional programming principles. STRIoT supports the composition of a
stream processing pipeline from eight purely functional operators. The
STRIoT system is designed to rewrite the supplied stream pipeline in
order to optimize its operation against a set of functional and
non-functional requirements. We compile a list of rewrite rules based on
a systematic pairwise comparison of the functional operators. We
classify each rule as total if it can be applied in any circumstance, or
partial if there are requirements on the input stream not expressed by
the type of the stream, and quantify those requirements.

== Background

description of striot
selection of operators

<table of operators>

    streamFilter    :: (a -> Bool) -> Stream a -> Stream a
    streamMap       :: (a -> b) -> Stream a -> Stream b
    streamFilterAcc :: (b -> a -> b) -> b -> (a -> b -> Bool) -> Stream a -> Stream a
    streamScan      :: (b -> a -> b) -> b -> Stream a -> Stream b
                    ::
    streamWindow    :: Stream a -> Stream [a]
    streamExpand    :: Stream [a] -> Stream a
                    ::
    streamMerge     :: Stream [a] -> Stream a

        XXX is this right? or is it [Stream a]

    streamJoin      :: Stream a -> Stream b -> Stream (a,b)

Ignoring the stream-in, stream-out parameters, the first four operators are
unary and their functional parameter operates on the payload of the stream,
and not the stream itself (the types of the HoFs do not include Stream)

The next four operators manipulate the structure of the stream itself.
StreamWindow eliminates the Event wrappers around the iotas that flow into
it and synthesises new ones for the collected iotes it outputs.

== Method

We constructed a list of operator pairs and considered each pair in
sequence in order to systematically explore all possible combinations.
For each pair, we initially attempted to reverse the order of the
operators whilst preserving their behaviour. For pairs of the same
operator, we attempt to construct an equivalent, single, fused operator.
For pairs of operators that are the dual of one another, we attempted to
eliminate them.

This method sometimes yielded a result that turned out not to behave
identically to the original pair in some or all circumstances. We noted
the behavioural differences

Once we had determined a viable rewrite rule, we examined whether its
inverse was a second, distinct viable rule.

=== Tools

Most of this exercise was conducted offline using pen and paper. For
some of the more complex rewrites, we sketched an outline on paper and
then attempted to encode the result in Haskell. Two Haskell libraries in
particular proved very useful for testing our work:
QuickCheck<<QuickCheck>> and
the Haskell Testing Framework<<HTF>>. Using these tools, we attempted to
construct a "property" that expressed the equivalence of the operator
pair before and after our rewrite. QuickCheck then generates a set of
randomly generated inputs and compares the output of each side of the
equation.

This provided some confidence that each rewrite rule was correct. It
also helped to catch a few cases where we had authored a rewrite rule we
thought was total, but wasn't. We then explored the failure cases to
determine whether the rule needed to be thrown out, or was useful in
some circumstances, in which case we noted the necessary caveats.

In order for QuickCheck to generate random Stream data, we were required
to provide a trivial implementation of the Arbitrary class for the
appropriate data type in STRIoT. This data type is higher-order, and so
to evaluate the properties, we needed to bind the type variables to
something concrete.  We chose `Char`, which has several nice properties:
it satisfies `Eq`, permitting the comparison of streams of `Chars`; it
satisfies `Ord`, simplifying the writing of predicates for
`streamFilter` and friends (we can use standard functions including `>=`
and `succ`).  Finally, when examining the output of operator-pairs in an
interactive session, `Char` is quite friendly to human eyes.

=== Describing rewrites

==== total/partial

We describe a rewrite as total if it can be applied to any occurance of
the pattern. Some rewrites are only applicable if some other properties
of the stream hold. These properties are not expressed in the definition
or type of the rewrite function. Indeed they may not be expressible due
to the limits of the type system.

(XXX there are no examples of partial rewrites in the examples below!
unless the not-order-preserving examples are what I am referring to here
)

==== Invertible

When a given rewrite rule can be inverted, such that the right-hand side
could be replaced by the left-hand side, it is described as
*invertible*. In some cases, this is true in theory but subject to a
caveat in practise, if the left-hand side would need to be decomposed in
order for the inverted rule to function. For example, We would not
normally expect to be able to reason about the composition of
higher-order-function parameters, such as filter predicates. Consider
the following rule

    filter (\x -> f x && g x) = filter f . filter g

This rule holds but can only be applied if we have the filter predicate
on the left-hand side expressed in this decomposable form, such that we
can refer to the sub-predicates independently on the right-hand side.
It's unlikely in practice that we will be able to inspect the internals
of the left-hand predicate.

Such invertible rules are described below as subject to a *decomposition
caveat*.

== TODO

filter promotion to filterAcc: the technique used fixes the type of the
spare accumulator (in this case to Char). This is probably not
necessary, and might point at a wider problem.

Classification of non-order-preserving rewrites: whether the re-ordering
is determined *internally* or *externally*. Internally means that
the re-ordering is entirely determined by the composition of stream
operators; external means that it is dependent on one of the externally
supplied arguments, such as the predicate supplied to streamFilter.

== Results

     1. `filter f . filter g = filter (\x -> f x && g x)`
        total; fusion; invertible with decomposition caveat (13)

     2. (and 3, 4) `filter f . filterAcc  / filterAcc  . filter f`
        promote filter f => filterAcc, then
        filterAcc . filterAcc = ...
        (partial: type unification issue; fusion)

[start=5]
     5. `streamFilter p . streamMap f = streamMap f . streamFilter (p . f)`
        total.
        efficiency of RHS:
        If p is highly selective, then the overhead of evaluating f
        twice per selected event may be lower than the savings made by
        reducing the list de/reconstruction overhead of streamMap.
        invertible with caveat (17)

     6. `streamMap f . streamMap g = streamMap (f . g)`
        total; fusion
        invertible with decomposition caveat (15) -- XXX wrong number (check all)

     7. `streamWindow w . streamMap f = streamMap (map f) . streamWindow w`
        total

     8. `streamJoin s1 . streamMap f = streamMap (\(x,y) -> (x, f y)) .  streamJoin s1`
        total
        invertible with decomposition caveat (16)

     9. `streamExpand . streamWindow _ = id`
        elimination; total
        XXX: this is not possible
        it's true that from the perspective of the stream payload this is equivalent to id
        but the metadata in the events coming into the window are lost (e.g. timestamps)

    10. `streamFilter f . streamExpand = streamExpand . streamMap (filter f)`
        total. invertible with decomposition caveat (17)

    11. `streamMap f . streamExpand = streamExpand . streamMap (map f)`
        total. invertible with decomposition caveat (18)

    12. `streamWindow w . streamExpand = id`
        elimination. XXX only tested w = chop n

    13. `streamMap f $ streamMerge [s1, s2]
        = streamMerge [streamMap f s1, streamMap f s2]`
        total, invertible

    14. `streamMerge [s1, streamMerge [s2, s3]]
        = streamMerge [s1, s2, s3]`
        total
        ordering preserved in the right-associative case
        invertible

    15. `streamFilterAcc af a p . streamMap f
        = streamMap f . streamFilterAcc af a (p . f)`
        total
        invertible w/ caveat as per #5

Many of the above rules are invertible, producing the following
additional rules:

[start=16]
    16. `filter (\x -> f x && g x) = filter f . filter g`

    17. `streamMap f . streamFilter (p . f) = streamFilter p . streamMap f`
        inversion caveat: we would not normally expect to receive (p . f)
        in a decomposable form.

    18. `streamMap (f . g) = streamMap f . streamMap g`

    19. `streamMap (\(x,y) -> (x, f y)) . streamJoin s1 = streamJoin s1 . streamMap f`

    20. `streamExpand . streamMap (filter f) = streamFilter f .  streamExpand`
        (XXX it would be good to write QuickCheck properties for the inversions)

    21. `streamExpand . streamMap (map f) = streamMap f . streamExpand`

    22. `streamMerge [streamMap f s1, streamMap f s2]
        = streamMap f $ streamMerge [s1, s2]`

    23. `streamMerge [s1, s2, s3]
        = streamMerge [s1, streamMerge [s2, s3]]`

12 rules
14 with filter/filterAcc separated out
22 adding inversions (with caveats)

It appears to not be possible to perform the same promotion/fusion trick
with streamScan as streamFilterAcc (XXX: Why?)

If ordering of stream items is not important, some additional rewrite
rules are available:

[start=24]
    24. `streamMerge [streamExpand s1, streamExpand s2]
        = streamExpand (streamMerge [s1,s2])`

    25. `streamExpand (streamMerge [w1,w2])
        = streamMerge [streamExpand w1, streamExpand w2]`

and their inverses

[start=26]
    26. `streamFilter f $ streammerge [s1, s2]
        = streamMerge [streamFilter f s1, streamFilter f s2]`

    27. `streamMerge [streamFilter f s1, streamFilter f s2]
        = streamFilter f $ streammerge [s1, s2]`

There are some issues to consider about constant or variable size of
lists in the case where the stream data type is a list, such as after
a streamWindow operator. In the case of streamWindow, the output list
size will be constant, but this is not reflected in the type.
(XXX: where does this matter?)

=== join

For pairs where the first operator is join, we know that the second
must operate on a tuple. However we cannot use this information to
decompose the arguments to higher order functions (filter or map), so in
general it seems no useful rewrites exist for this category of pairs.

== Conclusion

There are 64 pairings of 8 functional operators. Systematically looking
for ways to rewrite each pair whilst preserving the functional
definition yielded up to 25 rewrite rules: 14 rules classified as
applicable in any circumstance (total), a further 8 with caveats
discovered by testing for inversions of the first 14, and a further
3 partial rules that apply if the order of the stream items is not
significant.

These rules may prove useful as a base set of possible rewrites that
could be applied to a stream processing graph in order to change and/or
optimise the non-functional behaviour of the graph.

Examination of the rules, in particular the partial rules, has revealed
some properties of the graphs that, if encoded and provided to a rewrite
system, could aid in making more effective rewriting decisions. For
example if strict ordering of stream events is not important, then a
further 6 rewrite rules could be applied.

=== Further work

 * looking at triples or other combinations of operators
 * factoring in consideration of partitions
 * selection and encoding of additional information about streams for
   rewrite purposes

[bibliography]
== References

- [[[QuickCheck]]]
- [[[HTF]]]
